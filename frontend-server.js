const express = require('express');
const { Client } = require('pg');
const WebSocket = require('ws');
const path = require('path');

/*
üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´
üî•üî•üî• V6ÂâçÁ´ØÊúçÂãôÂô® - Â∞àÊ≥®ÊñºÊï∏ÊìöÈ°ØÁ§∫ÂíåÂàÜÊûê üî•üî•üî•

‚ö†Ô∏è ËÅ∑Ë≤¨ÂàÜÈõ¢Ôºö
- realtime-listener.js: Â∞àÊ≥®Êé•Êî∂ÂçÄÂ°äÈèàÊï∏Êìö
- frontend-server.js: Â∞àÊ≥®ÂâçÁ´ØÈ°ØÁ§∫ÂíåÊï∏ÊìöÂàÜÊûê

‚úÖ Ê†∏ÂøÉÂäüËÉΩÔºö
- HTTP APIÊúçÂãô (RESTÊé•Âè£)
- WebSocketÊúçÂãô (ÂØ¶ÊôÇÊé®ÈÄÅÁµ¶ÂâçÁ´Ø)
- PostgreSQL LISTEN (Êé•Êî∂realtime-listenerÁöÑÈÄöÁü•)
- Êï∏ÊìöÂàÜÊûêÊé•Âè£
- ÈùúÊÖãÊñá‰ª∂ÊúçÂãô

üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´üö´
*/

/**
 * V6ÂâçÁ´ØÊúçÂãôÂô®
 * 
 * üéØ ÂäüËÉΩÔºö
 * - Êé•Êî∂realtime-listenerÁöÑPostgreSQLÈÄöÁü•
 * - ÈÄöÈÅéWebSocketÊé®ÈÄÅÁµ¶ÂâçÁ´ØÈ†ÅÈù¢
 * - Êèê‰æõREST APIÊü•Ë©¢Êï∏Êìö
 * - ËôïÁêÜÊï∏ÊìöÂàÜÊûêË´ãÊ±Ç
 */
class V6FrontendServer {
    constructor() {
        // ÊúçÂãôÂô®ÈÖçÁΩÆ
        this.port = process.env.PORT || 3009;
        this.app = express();
        this.server = null;
        this.wss = null;
        
        // Êï∏ÊìöÂ∫´ÈÖçÁΩÆ
        this.connectionString = 'postgresql://neondb_owner:npg_QnreOCZz48UL@ep-wispy-meadow-a19m39a6-pooler.ap-southeast-1.aws.neon.tech/neondb?sslmode=require&channel_binding=require';
        this.db = null;
        this.notificationClient = null;
        
        // ÈÄ£Êé•ÁöÑWebSocketÂÆ¢Êà∂Á´Ø
        this.connectedClients = new Set();
        
        this.setupExpress();
    }

    /**
     * üîß Ë®≠ÁΩÆExpressÊáâÁî®
     */
    setupExpress() {
        // ‰∏≠Èñì‰ª∂
        this.app.use(express.json());
        this.app.use(express.static(path.join(__dirname, 'public')));
        
        // CORSË®≠ÁΩÆ
        this.app.use((req, res, next) => {
            res.header('Access-Control-Allow-Origin', '*');
            res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');
            res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
            next();
        });

        // Ë®≠ÁΩÆË∑ØÁî±
        this.setupRoutes();
    }

    /**
     * üõ£Ô∏è Ë®≠ÁΩÆAPIË∑ØÁî±
     */
    setupRoutes() {
        // ÂÅ•Â∫∑Ê™¢Êü•
        this.app.get('/api/health', (req, res) => {
            res.json({
                status: 'ok',
                timestamp: new Date().toISOString(),
                connectedClients: this.connectedClients.size,
                databaseConnected: this.db !== null
            });
        });

        // Áç≤ÂèñrealbetÂç≥ÊôÇÊï∏Êìö
        this.app.get('/api/realbet', async (req, res) => {
            try {
                const { epoch, limit = 100 } = req.query;
                
                let query, params;
                
                if (epoch) {
                    query = 'SELECT * FROM realbet WHERE epoch = $1 ORDER BY bet_ts DESC LIMIT $2';
                    params = [parseInt(epoch), parseInt(limit)];
                } else {
                    query = 'SELECT * FROM realbet ORDER BY bet_ts DESC LIMIT $1';
                    params = [parseInt(limit)];
                }
                
                const result = await this.db.query(query, params);
                
                res.json({
                    success: true,
                    data: result.rows,
                    count: result.rows.length
                });
                
            } catch (error) {
                console.error('‚ùå Áç≤ÂèñrealbetÊï∏ÊìöÂ§±Êïó:', error);
                res.status(500).json({
                    success: false,
                    error: error.message
                });
            }
        });

        // Áç≤ÂèñÊ≠∑Âè≤Êï∏ÊìöÁµ±Ë®à
        this.app.get('/api/stats', async (req, res) => {
            try {
                // Áµ±Ë®àrealbet‰∏≠ÁöÑÊï∏Êìö
                const statsQuery = `
                    SELECT 
                        epoch,
                        bet_direction,
                        COUNT(*) as bet_count,
                        SUM(amount::numeric) as total_amount,
                        AVG(amount::numeric) as avg_amount
                    FROM realbet 
                    GROUP BY epoch, bet_direction 
                    ORDER BY epoch DESC, bet_direction
                `;
                
                const result = await this.db.query(statsQuery);
                
                res.json({
                    success: true,
                    data: result.rows
                });
                
            } catch (error) {
                console.error('‚ùå Áç≤ÂèñÁµ±Ë®àÊï∏ÊìöÂ§±Êïó:', error);
                res.status(500).json({
                    success: false,
                    error: error.message
                });
            }
        });

        // Áç≤ÂèñÊåáÂÆöÂ±ÄÊ¨°ÁöÑË©≥Á¥∞Êï∏Êìö
        this.app.get('/api/epoch/:epoch', async (req, res) => {
            try {
                const { epoch } = req.params;
                
                const query = `
                    SELECT 
                        epoch,
                        bet_direction,
                        COUNT(*) as bet_count,
                        SUM(amount::numeric) as total_amount,
                        MIN(amount::numeric) as min_amount,
                        MAX(amount::numeric) as max_amount,
                        AVG(amount::numeric) as avg_amount
                    FROM realbet 
                    WHERE epoch = $1
                    GROUP BY epoch, bet_direction
                `;
                
                const detailQuery = `
                    SELECT * FROM realbet 
                    WHERE epoch = $1 
                    ORDER BY bet_ts DESC
                `;
                
                // Ê∑ªÂä†roundË°®Êü•Ë©¢Áç≤ÂèñÈéñÂÄâÊôÇÈñì
                const roundQuery = `
                    SELECT epoch, start_ts, lock_ts, close_ts, result
                    FROM round 
                    WHERE epoch = $1
                `;
                
                const [statsResult, detailResult, roundResult] = await Promise.all([
                    this.db.query(query, [epoch]),
                    this.db.query(detailQuery, [epoch]),
                    this.db.query(roundQuery, [epoch])
                ]);
                
                res.json({
                    success: true,
                    epoch: epoch,
                    stats: statsResult.rows,
                    details: detailResult.rows,
                    round: roundResult.rows[0] || null,
                    totalBets: detailResult.rows.length
                });
                
            } catch (error) {
                console.error('‚ùå Áç≤ÂèñÂ±ÄÊ¨°Ë©≥Á¥∞Êï∏ÊìöÂ§±Êïó:', error);
                res.status(500).json({
                    success: false,
                    error: error.message
                });
            }
        });

        // Áç≤ÂèñÈå¢ÂåÖ48Â±ÄWIN/LOSSË®òÈåÑ
        this.app.get('/api/wallet/:address/history', async (req, res) => {
            try {
                const { address } = req.params;
                const { start, end } = req.query;
                
                if (!start || !end) {
                    return res.json({
                        success: false,
                        error: 'Áº∫Â∞ëstartÊàñendÂèÉÊï∏'
                    });
                }
                
                const query = `
                    SELECT 
                        epoch,
                        bet_direction,
                        result,
                        amount
                    FROM hisbet 
                    WHERE wallet_address = $1 
                    AND epoch BETWEEN $2 AND $3
                    ORDER BY epoch DESC
                `;
                
                const result = await this.db.query(query, [address.toLowerCase(), parseInt(start), parseInt(end)]);
                
                res.json({
                    success: true,
                    count: result.rows.length,
                    records: result.rows.map(row => ({
                        epoch: parseInt(row.epoch),
                        direction: row.bet_direction,
                        result: row.result, // WIN/LOSS
                        amount: parseFloat(row.amount)
                    }))
                });
                
            } catch (error) {
                console.error('‚ùå Áç≤ÂèñÈå¢ÂåÖWIN/LOSSË®òÈåÑÂ§±Êïó:', error);
                res.json({
                    success: false,
                    error: error.message
                });
            }
        });

        // Áç≤ÂèñÈå¢ÂåÖÈ†òÁçéË®òÈåÑ
        this.app.get('/api/wallet/:address/claims', async (req, res) => {
            try {
                const { address } = req.params;
                
                const query = `
                    SELECT 
                        claim_count,
                        total_amount as total_claimed
                    FROM multi_claims 
                    WHERE wallet_address = $1
                `;
                
                const result = await this.db.query(query, [address]);
                
                if (result.rows[0] && result.rows[0].claim_count > 0) {
                    res.json({
                        success: true,
                        hasClaims: true,
                        data: {
                            claimCount: parseInt(result.rows[0].claim_count),
                            totalClaimed: parseFloat(result.rows[0].total_claimed).toFixed(4)
                        }
                    });
                } else {
                    res.json({
                        success: true,
                        hasClaims: false
                    });
                }
                
            } catch (error) {
                console.error('‚ùå Áç≤ÂèñÈå¢ÂåÖÈ†òÁçéË®òÈåÑÂ§±Êïó:', error);
                res.status(500).json({
                    success: false,
                    error: error.message
                });
            }
        });

        this.app.get('/', (req, res) => {
            res.sendFile(path.join(__dirname, 'public', 'index.html'));
        });
    }

    /**
     * üîÑ ÂàùÂßãÂåñÊúçÂãôÂô®
     */
    async initialize() {
        try {
            console.log('üîÑ ÂàùÂßãÂåñV6ÂâçÁ´ØÊúçÂãôÂô®...');
            
            // ÂàùÂßãÂåñÊï∏ÊìöÂ∫´ÈÄ£Êé•
            await this.initializeDatabase();
            console.log('‚úÖ V6ÂâçÁ´ØÊï∏ÊìöÂ∫´ÈÄ£Êé•ÊàêÂäü');
            
            // ÂïüÂãïHTTPÊúçÂãôÂô®
            await this.startHttpServer();
            console.log(`‚úÖ V6ÂâçÁ´ØHTTPÊúçÂãôÂô®ÂïüÂãï: http://localhost:${this.port}`);
            
            // ÂïüÂãïWebSocketÊúçÂãôÂô®
            this.startWebSocketServer();
            console.log('‚úÖ V6ÂâçÁ´ØWebSocketÊúçÂãôÂô®ÂïüÂãï');
            
            // ÂïüÂãïPostgreSQLÈÄöÁü•Áõ£ËÅΩ
            await this.startPostgreSQLListener();
            console.log('‚úÖ V6ÂâçÁ´ØPostgreSQLÈÄöÁü•Áõ£ËÅΩÂïüÂãï');
            
            console.log('üöÄ V6ÂâçÁ´ØÊúçÂãôÂô®ÂïüÂãïÂÆåÊàê');
            
        } catch (error) {
            console.error('‚ùå V6ÂâçÁ´ØÊúçÂãôÂô®ÂàùÂßãÂåñÂ§±Êïó:', error);
            throw error;
        }
    }

    /**
     * üîå ÂàùÂßãÂåñÊï∏ÊìöÂ∫´ÈÄ£Êé•
     */
    async initializeDatabase() {
        try {
            this.db = new Client({
                connectionString: this.connectionString,
                ssl: {
                    rejectUnauthorized: false
                }
            });

            await this.db.connect();
            
            // Ë®≠ÁΩÆÊôÇÂçÄÁÇ∫Âè∞ÂåóÊôÇÈñì
            await this.db.query("SET timezone = 'Asia/Taipei'");
            
            return true;
        } catch (error) {
            console.error('‚ùå V6ÂâçÁ´ØÊï∏ÊìöÂ∫´ÂàùÂßãÂåñÂ§±Êïó:', error.message);
            throw error;
        }
    }

    /**
     * üåê ÂïüÂãïHTTPÊúçÂãôÂô®
     */
    async startHttpServer() {
        return new Promise((resolve, reject) => {
            this.server = this.app.listen(this.port, (error) => {
                if (error) {
                    reject(error);
                } else {
                    resolve();
                }
            });
        });
    }

    /**
     * üîå ÂïüÂãïWebSocketÊúçÂãôÂô®
     */
    startWebSocketServer() {
        this.wss = new WebSocket.Server({ server: this.server });
        
        this.wss.on('connection', (ws, req) => {
            const clientId = `${req.socket.remoteAddress}:${req.socket.remotePort}`;
            console.log(`üì± Êñ∞ÁöÑWebSocketÂÆ¢Êà∂Á´ØÈÄ£Êé•: ${clientId}`);
            
            // Ê∑ªÂä†Âà∞ÈÄ£Êé•ÈõÜÂêà
            this.connectedClients.add(ws);
            
            // ÁôºÈÄÅÊ≠°ËøéÊ∂àÊÅØ
            ws.send(JSON.stringify({
                type: 'welcome',
                message: 'V6ÂâçÁ´ØWebSocketÈÄ£Êé•ÊàêÂäü',
                timestamp: new Date().toISOString(),
                clientId: clientId
            }));
            
            // ËôïÁêÜÂÆ¢Êà∂Á´ØÊ∂àÊÅØ
            ws.on('message', (message) => {
                try {
                    const data = JSON.parse(message);
                    console.log(`üì® Êî∂Âà∞ÂÆ¢Êà∂Á´ØÊ∂àÊÅØ:`, data);
                    
                    // ÂèØ‰ª•Âú®ÈÄôË£°ËôïÁêÜÂÆ¢Êà∂Á´ØÁöÑË´ãÊ±Ç
                    if (data.type === 'ping') {
                        ws.send(JSON.stringify({
                            type: 'pong',
                            timestamp: new Date().toISOString()
                        }));
                    }
                } catch (error) {
                    console.error('‚ùå ËôïÁêÜÂÆ¢Êà∂Á´ØÊ∂àÊÅØÂ§±Êïó:', error);
                }
            });
            
            // ËôïÁêÜÈÄ£Êé•ÈóúÈñâ
            ws.on('close', () => {
                console.log(`üì± WebSocketÂÆ¢Êà∂Á´ØÊñ∑Èñã: ${clientId}`);
                this.connectedClients.delete(ws);
            });
            
            // ËôïÁêÜÈÄ£Êé•ÈåØË™§
            ws.on('error', (error) => {
                console.error(`‚ùå WebSocketÂÆ¢Êà∂Á´ØÈåØË™§ ${clientId}:`, error);
                this.connectedClients.delete(ws);
            });
        });
    }

    /**
     * üì° ÂïüÂãïPostgreSQLÈÄöÁü•Áõ£ËÅΩ
     */
    async startPostgreSQLListener() {
        try {
            // ÂâµÂª∫Â∞àÈñÄÁî®ÊñºÁõ£ËÅΩÁöÑÊï∏ÊìöÂ∫´ÈÄ£Êé•
            this.notificationClient = new Client({
                connectionString: this.connectionString,
                ssl: {
                    rejectUnauthorized: false
                }
            });
            
            await this.notificationClient.connect();
            
            // Áõ£ËÅΩrealtime-listenerÁôºÈÄÅÁöÑÈÄöÁü•
            await this.notificationClient.query('LISTEN new_bet_data');
            await this.notificationClient.query('LISTEN realtime_status');
            
            // ËôïÁêÜÈÄöÁü•‰∫ã‰ª∂
            this.notificationClient.on('notification', (msg) => {
                try {
                    console.log(`üì° Êî∂Âà∞PostgreSQLÈÄöÁü•: ${msg.channel}`);
                    
                    const data = JSON.parse(msg.payload);
                    
                    // ËΩâÁôºÁµ¶ÊâÄÊúâWebSocketÂÆ¢Êà∂Á´Ø
                    this.broadcastToClients({
                        type: 'postgres_notification',
                        channel: msg.channel,
                        data: data,
                        timestamp: new Date().toISOString()
                    });
                    
                } catch (error) {
                    console.error('‚ùå ËôïÁêÜPostgreSQLÈÄöÁü•Â§±Êïó:', error);
                }
            });
            
        } catch (error) {
            console.error('‚ùå PostgreSQLÈÄöÁü•Áõ£ËÅΩÂïüÂãïÂ§±Êïó:', error);
            throw error;
        }
    }

    /**
     * üì¢ Âª£Êí≠Ê∂àÊÅØÁµ¶ÊâÄÊúâWebSocketÂÆ¢Êà∂Á´Ø
     */
    broadcastToClients(message) {
        const messageStr = JSON.stringify(message);
        let successCount = 0;
        let failCount = 0;
        
        this.connectedClients.forEach((ws) => {
            try {
                if (ws.readyState === WebSocket.OPEN) {
                    ws.send(messageStr);
                    successCount++;
                } else {
                    this.connectedClients.delete(ws);
                    failCount++;
                }
            } catch (error) {
                console.error('‚ùå ÁôºÈÄÅWebSocketÊ∂àÊÅØÂ§±Êïó:', error);
                this.connectedClients.delete(ws);
                failCount++;
            }
        });
        
        if (successCount > 0) {
            console.log(`üì¢ Â∑≤Âª£Êí≠Áµ¶ ${successCount} ÂÄãÂÆ¢Êà∂Á´Ø${failCount > 0 ? `ÔºåÊ∏ÖÁêÜ ${failCount} ÂÄãÁÑ°ÊïàÈÄ£Êé•` : ''}`);
        }
    }

    /**
     * üßπ Ê∏ÖÁêÜË≥áÊ∫ê
     */
    cleanup() {
        if (this.notificationClient) {
            this.notificationClient.end();
        }
        if (this.db) {
            this.db.end();
        }
        if (this.wss) {
            this.wss.close();
        }
        if (this.server) {
            this.server.close();
        }
        console.log('‚úÖ V6ÂâçÁ´ØÊúçÂãôÂô®Â∑≤Ê∏ÖÁêÜ');
    }
}

// Â¶ÇÊûúÁõ¥Êé•ÈÅãË°åÊ≠§Êñá‰ª∂
if (require.main === module) {
    const frontendServer = new V6FrontendServer();
    
    // ÂÑ™ÈõÖÈóúÈñâËôïÁêÜ
    process.on('SIGINT', () => {
        console.log('\nüõë Êé•Êî∂Âà∞ÈóúÈñâ‰ø°ËôüÔºåÊ≠£Âú®Ê∏ÖÁêÜV6ÂâçÁ´ØË≥áÊ∫ê...');
        frontendServer.cleanup();
        process.exit(0);
    });
    
    process.on('SIGTERM', () => {
        console.log('\nüõë Êé•Êî∂Âà∞ÁµÇÊ≠¢‰ø°ËôüÔºåÊ≠£Âú®Ê∏ÖÁêÜV6ÂâçÁ´ØË≥áÊ∫ê...');
        frontendServer.cleanup();
        process.exit(0);
    });
    
    frontendServer.initialize().catch(error => {
        console.error('‚ùå V6ÂâçÁ´ØÊúçÂãôÂô®ÂïüÂãïÂ§±Êïó:', error);
        process.exit(1);
    });
}

module.exports = V6FrontendServer;